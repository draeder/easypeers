const crypto=require('crypto')
const{EventEmitter}=require('events')
const WebTorrent=require('webtorrent')
const Zerok=require('zerok')
EventEmitter.defaultMaxListeners=25
const PREFIX='easypeers-'
const Easypeers=function(identifier,args){let easypeers=this
let zerok=new Zerok(256)
if(typeof identifier==='object'){easypeers.opts={...identifier}}else{easypeers.opts={...args}}
const events=new EventEmitter()
easypeers.on=events.on.bind(events)
easypeers.once=events.once.bind(events)
easypeers.emit=events.emit.bind(events)
easypeers.off=events.off.bind(events)
easypeers.removeAllListeners=events.removeAllListeners.bind(events)
easypeers.maxPeers=easypeers.opts.maxPeers||6
easypeers.coverage=easypeers.opts.coverage||0.33
if(easypeers.maxPeers<2)easypeers.maxPeers=2
easypeers.timeout=easypeers.opts.timeout||30*1000
easypeers.identifier=easypeers.opts.identifer||crypto.createHash('sha1').update(PREFIX+easypeers.opts.identifier).digest().toString('hex')||crypto.createHash('sha1').update(PREFIX+crypto.randomBytes(20).toString('hex')).digest().toString('hex')
easypeers.address=easypeers.opts.address||crypto.randomBytes(20).toString('hex')
const hash=crypto.createHash('sha256')
hash.update(easypeers.identifier)
const seed=hash.digest()
easypeers.wires={}
let seen={}
let client=new WebTorrent({dht:false,lsd:false,peerId:easypeers.address})
let opts={infoHash:easypeers.identifier,peerId:easypeers.address,announce:[easypeers.opts.tracker?easypeers.opts.tracker:'','wss://tracker.peer.ooo','wss://tracker.openwebtorrent.com',],port:process?easypeers.opts.port||6881:undefined}
let torrent=client.add(opts)
client.on('warning',err=>{console.warning('Warning',err)})
client.on('error',err=>{console.error('Error',err)})
function calculateDistance(hash1,hash2){const hexDigits='0123456789abcdef'
let distance=''
for(let i=0;i<hash1.length;i++){const digit1=hexDigits.indexOf(hash1[i])
const digit2=hexDigits.indexOf(hash2[i])
const diff=(digit1-digit2+16)%16
distance+=hexDigits[diff]}
return distance}
function findClosestPeers(targetPeerHash,knownPeers,maxPeers,ratio){const k=Math.round(maxPeers*ratio)
const distances=knownPeers.map(peer=>({peer,distance:calculateDistance(targetPeerHash,peer)}))
distances.sort((a,b)=>a.distance.localeCompare(b.distance,'en',{numeric:true}))
const closestPeers=distances.slice(0,Math.min(k,knownPeers.length)).map(d=>d.peer)
return closestPeers.slice(0,maxPeers)}
easypeers.wireCount=0
torrent.on("wire",function(wire){wire.on('close',()=>{easypeers.wireCount--
if(easypeers.wireCount<0)easypeers.wireCount=0
delete easypeers.wires[wire.peerId]
if(torrent&&torrent.numPeers<=2&&torrent.numPeers<easypeers.maxPeers&&easypeers.wireCount<2){torrent.resume()
torrent.announce[opts.announce]}
easypeers.peerCount=torrent.numPeers
if(wire._writableState.emitClose&&seen[wire.peerId]&&new Date().getTime()-seen[wire.peerId].when>new Date().getTime()-(2*60*1000))
easypeers.emit('disconnect',wire.peerId)
wire.removeAllListeners()
wire=null})
if(easypeers.wires.hasOwnProperty(wire.peerId)){wire.destroy()
return}
if(easypeers.wireCount<easypeers.maxPeers){easypeers.wires[wire.peerId]=wire
easypeers.wires[wire.peerId].use(_easypeers(easypeers.wires[wire.peerId]))
easypeers.wireCount++
easypeers.peerCount=torrent.numPeers}else{wire.destroy()
return}})
function isValidJSON(json){try{JSON.parse(json)
return true}catch(e){return false}}
easypeers.send=(to,data)=>{let message={}
let sendTo
if(to&&data){sendTo=to}
if(data===undefined){data=to}
if(typeof data==='number'){data=data.toString()}
data=data.toString()
if(!isNaN(data)){message={id:crypto.createHash('sha1').update(data,'binary').digest('hex')+Math.random(),has:Object.keys(easypeers.wires),message:data,}}else if(isValidJSON(data)){try{message=JSON.parse(data)
message.has=Object.keys(easypeers.wires)
message.id=crypto.createHash('sha1').update(data,'binary').digest('hex')+Math.random()}catch(err){console.error(err)}}else{message={id:crypto.createHash('sha1').update(data,'binary').digest('hex')+Math.random(),has:Object.keys(easypeers.wires),message:data,}}
message.from=easypeers.address
message.certificate={id:zerok.proof(message.id),from:zerok.proof([message.from]),message:zerok.proof(message.message),pubkey:zerok.keypair.publicKey,}
if(easypeers.opts.debug)console.debug('sendTo: '+sendTo)
if(sendTo){message.to=sendTo
let knownPeers=Object.keys(easypeers.wires)
let closePeers=findClosestPeers(message.to,knownPeers,easypeers.maxPeers,easypeers.coverage)
if(easypeers.debug)console.debug('Sending direct message to '+message.to+' via '+closePeers)
for(let wire of closePeers){try{if(easypeers.wires[wire]){easypeers.wires[wire].extended('sw_easypeers',JSON.stringify(message))
if(easypeers.opts.debug)console.log('Sent message to: '+wire)}}catch(e){if(easypeers.debug)console.error(e)}}}else{let knownPeers=Object.keys(easypeers.wires)
if(easypeers.debug)console.debug('Sending broadcast message to all peers')
for(let wire of knownPeers){try{if(easypeers.wires[wire]){easypeers.wires[wire].extended('sw_easypeers',JSON.stringify(message))
if(easypeers.opts.debug)console.log('Sent message to: '+wire)}}catch(e){if(easypeers.debug)console.error(e)}}}}
setInterval(()=>{torrent.announce[opts.announce]},easypeers.timeout)
let last
let sentMessages={}
let seenMessages={}
let _easypeers=()=>{let swEasypeers=function(wire){easypeers.wires[wire.peerId].extendedHandshake.keys='SEA Pairs'
this.onHandshake=(infoHash,peerId,extensions)=>{seen[wire.peerId]={when:new Date().getTime()}}
this.onExtendedHandshake=(handshake)=>{if(new Date().getTime()-seen[wire.peerId].when<new Date().getTime()-(5*60*1000))
easypeers.emit('connect',wire.peerId)}
this.onMessage=function(message){message=message.toString()
try{message=message.substring(message.indexOf(':')+1)
message=JSON.parse(message,(key,value)=>{if(typeof value==='string'&&value.startsWith('`')&&value.endsWith('`')){const strippedValue=value.slice(1,-1)
try{const parsedObject=JSON.parse(strippedValue)
if(typeof parsedObject==='object'&&parsedObject!==null){return parsedObject}}catch{}}
return value})
if(!zerok.verify(message.id,message.certificate.id,message.certificate.pubkey)||!zerok.verify(message.from,message.certificate.from,message.certificate.pubkey)||!zerok.verify(message.message,message.certificate.message,message.certificate.pubkey)){return}
if(!seenMessages[message.id]){seenMessages[message.id]=true}else{if(easypeers.opts.debug)console.log(`Duplicate message ${message.id}received,ignoring`)
return}
if(message.to){if(!Array.isArray(message.to))message.to=[message.to]
if(message.to.includes(easypeers.address)){if(easypeers.opts.debug)console.log(`Received direct message from ${message.from}:`,message.message)
easypeers.emit('message',{from:message.from,message:message.message})
return}else{message.has.push(easypeers.address)
let peers=Object.keys(easypeers.wires)
for(let i=0;i<peers.length;i++){let peer=peers[i]
if(peer===message.from||message.has.includes(peer)){if(easypeers.opts.debug)console.log(`Skipping peer ${peer}for message ${message.id}`)}else{if(easypeers.opts.debug)console.log(`Forwarding message ${message.id}to peer ${peer}`)
if(!sentMessages[message.id]){sentMessages[message.id]=[]}
sentMessages[message.id].push(peer)
easypeers.wires[peer].extended('sw_easypeers',JSON.stringify(message),()=>{easypeers.wires[peer].on('messageAck',(ack)=>{if(ack===message.id){if(easypeers.opts.debug)console.log(`Received acknowledgment from peer ${peer}for message ${message.id}`)}})})}}
return}}
if(easypeers.opts.debug)console.log(`Received message from ${message.from}:`,message.message)
easypeers.emit('message',message)
message.has.push(easypeers.address)
let peers=Object.keys(easypeers.wires)
for(let i=0;i<peers.length;i++){let peer=peers[i]
if(peer===message.from||message.has.includes(peer)){if(easypeers.opts.debug)console.log(`Skipping peer ${peer}for message ${message.id}`)}else{if(easypeers.opts.debug)console.log(`Forwarding message ${message.id}to peer ${peer}`)
if(!sentMessages[message.id]){sentMessages[message.id]=[]}
sentMessages[message.id].push(peer)
easypeers.wires[peer].extended('sw_easypeers',JSON.stringify(message),()=>{easypeers.wires[peer].on('messageAck',(ack)=>{if(ack===message.id){if(easypeers.opts.debug)console.log(`Received acknowledgment from peer ${peer}for message ${message.id}`)}})})}}}catch(err){}}}
swEasypeers.prototype.name='sw_easypeers'
return swEasypeers}}
module.exports=Easypeers